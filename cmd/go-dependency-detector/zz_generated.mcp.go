// Code generated by forge-dev. DO NOT EDIT.
// Source: spec.openapi.yaml
// SourceChecksum: sha256:41d57a0100d1375861d45c3a2d9323e60fe98ea1f641a3976a5885eedd68bcbe

package main

import (
	"context"
	"fmt"

	"github.com/alexandremahdhaoui/forge/pkg/mcpserver"
	"github.com/alexandremahdhaoui/forge/pkg/mcptypes"
	"github.com/alexandremahdhaoui/forge/pkg/mcputil"
	"github.com/modelcontextprotocol/go-sdk/mcp"
)

// SetupMCPServerBase creates and configures the base MCP server.
// It registers only the config-validate tool. The detectDependencies tool
// must be registered manually since each detector has different input types.
func SetupMCPServerBase(name string, version string) (*mcpserver.Server, error) {
	server := mcpserver.New(name, version)

	// Register config-validate tool
	mcpserver.RegisterTool(server, &mcp.Tool{
		Name:        "config-validate",
		Description: fmt.Sprintf("Validate %s configuration", name),
	}, handleConfigValidate)

	return server, nil
}

// handleConfigValidate handles the config-validate MCP tool.
func handleConfigValidate(
	_ context.Context,
	_ *mcp.CallToolRequest,
	input mcptypes.ConfigValidateInput,
) (*mcp.CallToolResult, any, error) {
	output := ValidateMap(input.Spec)

	if output.Valid {
		result, artifact := mcputil.SuccessResultWithArtifact(
			"Configuration is valid",
			output,
		)
		return result, artifact, nil
	}

	result, artifact := mcputil.SuccessResultWithArtifact(
		fmt.Sprintf("Configuration validation failed with %d error(s)", len(output.Errors)),
		output,
	)
	return result, artifact, nil
}
