// Code generated by forge-dev. DO NOT EDIT.
// Source: spec.openapi.yaml
// SourceChecksum: sha256:manual-migration-testenv-lcr

package main

import (
	"fmt"
)

// Spec contains the configuration for this engine.
// These fields are populated from the 'spec' field in forge.yaml.
type Spec struct {
	// Whether the local container registry is enabled
	Enabled bool `json:"enabled,omitempty"`
	// Kubernetes namespace for the registry deployment
	Namespace string `json:"namespace,omitempty"`
	// List of namespaces to create image pull secrets in
	ImagePullSecretNamespaces []string `json:"imagePullSecretNamespaces,omitempty"`
	// Name of the image pull secret to create
	ImagePullSecretName string `json:"imagePullSecretName,omitempty"`
}

// FromMap creates a Spec from a map[string]interface{}.
// This is used to parse the spec field from forge.yaml.
func FromMap(m map[string]interface{}) (*Spec, error) {
	if m == nil {
		return &Spec{}, nil
	}

	s := &Spec{}

	// Parse enabled
	if v, ok := m["enabled"]; ok && v != nil {
		if val, ok := v.(bool); ok {
			s.Enabled = val
		} else {
			return nil, fmt.Errorf("field enabled: expected bool, got %T", v)
		}
	}

	// Parse namespace
	if v, ok := m["namespace"]; ok && v != nil {
		if val, ok := v.(string); ok {
			s.Namespace = val
		} else {
			return nil, fmt.Errorf("field namespace: expected string, got %T", v)
		}
	}

	// Parse imagePullSecretNamespaces
	if v, ok := m["imagePullSecretNamespaces"]; ok && v != nil {
		if arr, ok := v.([]interface{}); ok {
			s.ImagePullSecretNamespaces = make([]string, 0, len(arr))
			for i, item := range arr {
				if str, ok := item.(string); ok {
					s.ImagePullSecretNamespaces = append(s.ImagePullSecretNamespaces, str)
				} else {
					return nil, fmt.Errorf("field imagePullSecretNamespaces[%d]: expected string, got %T", i, item)
				}
			}
		} else {
			return nil, fmt.Errorf("field imagePullSecretNamespaces: expected array, got %T", v)
		}
	}

	// Parse imagePullSecretName
	if v, ok := m["imagePullSecretName"]; ok && v != nil {
		if val, ok := v.(string); ok {
			s.ImagePullSecretName = val
		} else {
			return nil, fmt.Errorf("field imagePullSecretName: expected string, got %T", v)
		}
	}

	return s, nil
}

// ToMap converts a Spec to a map[string]interface{}.
// This is used for serialization and testing.
func (s *Spec) ToMap() map[string]interface{} {
	if s == nil {
		return nil
	}

	m := make(map[string]interface{})

	if s.Enabled {
		m["enabled"] = s.Enabled
	}

	if s.Namespace != "" {
		m["namespace"] = s.Namespace
	}

	if len(s.ImagePullSecretNamespaces) > 0 {
		m["imagePullSecretNamespaces"] = s.ImagePullSecretNamespaces
	}

	if s.ImagePullSecretName != "" {
		m["imagePullSecretName"] = s.ImagePullSecretName
	}

	return m
}
