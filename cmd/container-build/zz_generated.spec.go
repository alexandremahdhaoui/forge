// Code generated by forge-dev. DO NOT EDIT.
// Source: spec.openapi.yaml
// SourceChecksum: sha256:93abc4bf66872c4f411ab6dc112bfddb35fa4d2508725503e33e9c0d254e9d7d

package main

import (
	"fmt"
)

// Spec contains the configuration for this engine.
// These fields are populated from the 'spec' field in forge.yaml.
type Spec struct {
	// Build arguments (optional)
	BuildArgs map[string]string `json:"buildArgs,omitempty"`
	// Build context path (optional)
	Context string `json:"context,omitempty"`
	// Path to Dockerfile (optional)
	Dockerfile string `json:"dockerfile,omitempty"`
	// Whether to push image (optional)
	Push bool `json:"push,omitempty"`
	// Registry URL (optional)
	Registry string `json:"registry,omitempty"`
	// Image tags (optional)
	Tags []string `json:"tags,omitempty"`
	// Build target stage (optional)
	Target string `json:"target,omitempty"`
}

// FromMap creates a Spec from a map[string]interface{}.
// This is used to parse the spec field from forge.yaml.
func FromMap(m map[string]interface{}) (*Spec, error) {
	if m == nil {
		return &Spec{}, nil
	}

	s := &Spec{}

	// Parse buildArgs
	if v, ok := m["buildArgs"]; ok && v != nil {
		if mapVal, ok := v.(map[string]interface{}); ok {
			s.BuildArgs = make(map[string]string, len(mapVal))
			for key, val := range mapVal {
				if str, ok := val.(string); ok {
					s.BuildArgs[key] = str
				} else {
					return nil, fmt.Errorf("field buildArgs[%s]: expected string, got %T", key, val)
				}
			}
		} else if mapVal, ok := v.(map[string]string); ok {
			s.BuildArgs = mapVal
		} else {
			return nil, fmt.Errorf("field buildArgs: expected map[string]string, got %T", v)
		}
	}

	// Parse context
	if v, ok := m["context"]; ok && v != nil {
		if val, ok := v.(string); ok {
			s.Context = val
		} else {
			return nil, fmt.Errorf("field context: expected string, got %T", v)
		}
	}

	// Parse dockerfile
	if v, ok := m["dockerfile"]; ok && v != nil {
		if val, ok := v.(string); ok {
			s.Dockerfile = val
		} else {
			return nil, fmt.Errorf("field dockerfile: expected string, got %T", v)
		}
	}

	// Parse push
	if v, ok := m["push"]; ok && v != nil {
		if val, ok := v.(bool); ok {
			s.Push = val
		} else {
			return nil, fmt.Errorf("field push: expected bool, got %T", v)
		}
	}

	// Parse registry
	if v, ok := m["registry"]; ok && v != nil {
		if val, ok := v.(string); ok {
			s.Registry = val
		} else {
			return nil, fmt.Errorf("field registry: expected string, got %T", v)
		}
	}

	// Parse tags
	if v, ok := m["tags"]; ok && v != nil {
		if arr, ok := v.([]interface{}); ok {
			s.Tags = make([]string, 0, len(arr))
			for i, item := range arr {
				if str, ok := item.(string); ok {
					s.Tags = append(s.Tags, str)
				} else {
					return nil, fmt.Errorf("field tags[%d]: expected string, got %T", i, item)
				}
			}
		} else if arr, ok := v.([]string); ok {
			s.Tags = arr
		} else {
			return nil, fmt.Errorf("field tags: expected []string, got %T", v)
		}
	}

	// Parse target
	if v, ok := m["target"]; ok && v != nil {
		if val, ok := v.(string); ok {
			s.Target = val
		} else {
			return nil, fmt.Errorf("field target: expected string, got %T", v)
		}
	}

	return s, nil
}

// ToMap converts a Spec to a map[string]interface{}.
// This is used for serialization and testing.
func (s *Spec) ToMap() map[string]interface{} {
	if s == nil {
		return nil
	}

	m := make(map[string]interface{})

	if len(s.BuildArgs) > 0 {
		m["buildArgs"] = s.BuildArgs
	}

	if s.Context != "" {
		m["context"] = s.Context
	}

	if s.Dockerfile != "" {
		m["dockerfile"] = s.Dockerfile
	}

	if s.Push {
		m["push"] = s.Push
	}

	if s.Registry != "" {
		m["registry"] = s.Registry
	}

	if len(s.Tags) > 0 {
		m["tags"] = s.Tags
	}

	if s.Target != "" {
		m["target"] = s.Target
	}

	return m
}
