// Code generated by forge-dev. DO NOT EDIT.
// Source: spec.openapi.yaml
// SourceChecksum: sha256:d15c3ce2192cbabeba2b02d1df6f99a80e3cd34e24904e5aacec904321ec3e8a

package main

import (
	"fmt"
)

// Spec represents the Spec configuration.
// Configuration for go-gen-protobuf engine
type Spec struct {
	// Additional raw protoc arguments
	ExtraArgs []string `json:"extraArgs,omitempty"`
	// --go-grpc_opt value (default "paths=source_relative")
	GoGrpcOpt string `json:"goGrpcOpt,omitempty"`
	// --go_opt value (default "paths=source_relative")
	GoOpt string `json:"goOpt,omitempty"`
	// Additional include paths for protoc (optional)
	Includes []string `json:"includes,omitempty"`
	// Directory for generated Go code (optional)
	OutputDir string `json:"outputDir,omitempty"`
	// --plugin values
	Plugin []string `json:"plugin,omitempty"`
	// Directory containing .proto files (optional)
	ProtoDir string `json:"protoDir,omitempty"`
	// Additional --proto_path values
	ProtoPath []string `json:"protoPath,omitempty"`
}

// SpecFromMap creates a Spec from a map[string]interface{}.
func SpecFromMap(m map[string]interface{}) (*Spec, error) {
	if m == nil {
		return &Spec{}, nil
	}

	s := &Spec{}
	// Parse extraArgs
	if v, ok := m["extraArgs"]; ok && v != nil {
		if arr, ok := v.([]interface{}); ok {
			s.ExtraArgs = make([]string, 0, len(arr))
			for i, item := range arr {
				if str, ok := item.(string); ok {
					s.ExtraArgs = append(s.ExtraArgs, str)
				} else {
					return nil, fmt.Errorf("field extraArgs[%d]: expected string, got %T", i, item)
				}
			}
		} else if arr, ok := v.([]string); ok {
			s.ExtraArgs = arr
		} else {
			return nil, fmt.Errorf("field extraArgs: expected []string, got %T", v)
		}
	}
	// Parse goGrpcOpt
	if v, ok := m["goGrpcOpt"]; ok && v != nil {
		if val, ok := v.(string); ok {
			s.GoGrpcOpt = val
		} else {
			return nil, fmt.Errorf("field goGrpcOpt: expected string, got %T", v)
		}
	}
	// Parse goOpt
	if v, ok := m["goOpt"]; ok && v != nil {
		if val, ok := v.(string); ok {
			s.GoOpt = val
		} else {
			return nil, fmt.Errorf("field goOpt: expected string, got %T", v)
		}
	}
	// Parse includes
	if v, ok := m["includes"]; ok && v != nil {
		if arr, ok := v.([]interface{}); ok {
			s.Includes = make([]string, 0, len(arr))
			for i, item := range arr {
				if str, ok := item.(string); ok {
					s.Includes = append(s.Includes, str)
				} else {
					return nil, fmt.Errorf("field includes[%d]: expected string, got %T", i, item)
				}
			}
		} else if arr, ok := v.([]string); ok {
			s.Includes = arr
		} else {
			return nil, fmt.Errorf("field includes: expected []string, got %T", v)
		}
	}
	// Parse outputDir
	if v, ok := m["outputDir"]; ok && v != nil {
		if val, ok := v.(string); ok {
			s.OutputDir = val
		} else {
			return nil, fmt.Errorf("field outputDir: expected string, got %T", v)
		}
	}
	// Parse plugin
	if v, ok := m["plugin"]; ok && v != nil {
		if arr, ok := v.([]interface{}); ok {
			s.Plugin = make([]string, 0, len(arr))
			for i, item := range arr {
				if str, ok := item.(string); ok {
					s.Plugin = append(s.Plugin, str)
				} else {
					return nil, fmt.Errorf("field plugin[%d]: expected string, got %T", i, item)
				}
			}
		} else if arr, ok := v.([]string); ok {
			s.Plugin = arr
		} else {
			return nil, fmt.Errorf("field plugin: expected []string, got %T", v)
		}
	}
	// Parse protoDir
	if v, ok := m["protoDir"]; ok && v != nil {
		if val, ok := v.(string); ok {
			s.ProtoDir = val
		} else {
			return nil, fmt.Errorf("field protoDir: expected string, got %T", v)
		}
	}
	// Parse protoPath
	if v, ok := m["protoPath"]; ok && v != nil {
		if arr, ok := v.([]interface{}); ok {
			s.ProtoPath = make([]string, 0, len(arr))
			for i, item := range arr {
				if str, ok := item.(string); ok {
					s.ProtoPath = append(s.ProtoPath, str)
				} else {
					return nil, fmt.Errorf("field protoPath[%d]: expected string, got %T", i, item)
				}
			}
		} else if arr, ok := v.([]string); ok {
			s.ProtoPath = arr
		} else {
			return nil, fmt.Errorf("field protoPath: expected []string, got %T", v)
		}
	}
	return s, nil
}

// ToMap converts a Spec to a map[string]interface{}.
func (s *Spec) ToMap() map[string]interface{} {
	if s == nil {
		return nil
	}

	m := make(map[string]interface{})
	if len(s.ExtraArgs) > 0 {
		m["extraArgs"] = s.ExtraArgs
	}
	if s.GoGrpcOpt != "" {
		m["goGrpcOpt"] = s.GoGrpcOpt
	}
	if s.GoOpt != "" {
		m["goOpt"] = s.GoOpt
	}
	if len(s.Includes) > 0 {
		m["includes"] = s.Includes
	}
	if s.OutputDir != "" {
		m["outputDir"] = s.OutputDir
	}
	if len(s.Plugin) > 0 {
		m["plugin"] = s.Plugin
	}
	if s.ProtoDir != "" {
		m["protoDir"] = s.ProtoDir
	}
	if len(s.ProtoPath) > 0 {
		m["protoPath"] = s.ProtoPath
	}
	return m
}

// FromMap creates a Spec from a map[string]interface{}.
// This is the main entry point for parsing the spec field from forge.yaml.
func FromMap(m map[string]interface{}) (*Spec, error) {
	return SpecFromMap(m)
}
