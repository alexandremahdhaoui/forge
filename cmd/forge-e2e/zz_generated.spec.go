// Code generated by forge-dev. DO NOT EDIT.
// Source: spec.openapi.yaml
// SourceChecksum: sha256:c0619ca0baa98fb2b1070a1f981604dfb7b19c4dc20d9e270002498df5d314db

package main

import (
	"fmt"
)

// Spec contains the configuration for this engine.
// These fields are populated from the 'spec' field in forge.yaml.
type Spec struct {
	// Filter tests by category (build, testenv, test-runner, prompt, system, error, cleanup, mcp, performance, artifact-store)
	Category string `json:"category,omitempty"`
	// Filter tests by name pattern (case-insensitive substring match)
	NamePattern string `json:"namePattern,omitempty"`
}

// FromMap creates a Spec from a map[string]interface{}.
// This is used to parse the spec field from forge.yaml.
func FromMap(m map[string]interface{}) (*Spec, error) {
	if m == nil {
		return &Spec{}, nil
	}

	s := &Spec{}

	// Parse category
	if v, ok := m["category"]; ok && v != nil {
		if val, ok := v.(string); ok {
			s.Category = val
		} else {
			return nil, fmt.Errorf("field category: expected string, got %T", v)
		}
	}

	// Parse namePattern
	if v, ok := m["namePattern"]; ok && v != nil {
		if val, ok := v.(string); ok {
			s.NamePattern = val
		} else {
			return nil, fmt.Errorf("field namePattern: expected string, got %T", v)
		}
	}

	return s, nil
}

// ToMap converts a Spec to a map[string]interface{}.
// This is used for serialization and testing.
func (s *Spec) ToMap() map[string]interface{} {
	if s == nil {
		return nil
	}

	m := make(map[string]interface{})

	if s.Category != "" {
		m["category"] = s.Category
	}

	if s.NamePattern != "" {
		m["namePattern"] = s.NamePattern
	}

	return m
}
