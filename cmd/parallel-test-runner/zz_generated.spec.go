// Code generated by forge-dev. DO NOT EDIT.
// Source: spec.openapi.yaml
// SourceChecksum: sha256:52b14b5cea709c37bdef55327f0ade8ee47c980ab36532ec9c53e559f611223e

package main

import (
	"fmt"
)

// Spec represents the Spec configuration.
// Configuration for parallel-test-runner engine
type Spec struct {
	// Name of the runner whose coverage is used. If not specified or runner not found, Coverage.Enabled=false in result.
	PrimaryCoverageRunner string `json:"primaryCoverageRunner,omitempty"`
	// List of test runners to execute in parallel. Each item must be an object with 'name' (required), 'engine' (required), and 'spec' (optional) fields.
	Runners []interface{} `json:"runners"`
}

// SpecFromMap creates a Spec from a map[string]interface{}.
func SpecFromMap(m map[string]interface{}) (*Spec, error) {
	if m == nil {
		return &Spec{}, nil
	}

	s := &Spec{}
	// Parse primaryCoverageRunner
	if v, ok := m["primaryCoverageRunner"]; ok && v != nil {
		if val, ok := v.(string); ok {
			s.PrimaryCoverageRunner = val
		} else {
			return nil, fmt.Errorf("field primaryCoverageRunner: expected string, got %T", v)
		}
	}
	// Parse runners
	if v, ok := m["runners"]; ok && v != nil {
		if arr, ok := v.([]interface{}); ok {
			s.Runners = make([]interface{}, 0, len(arr))
			for _, item := range arr {
				s.Runners = append(s.Runners, item.(interface{}))
			}
		} else {
			return nil, fmt.Errorf("field runners: expected array, got %T", v)
		}
	}
	return s, nil
}

// ToMap converts a Spec to a map[string]interface{}.
func (s *Spec) ToMap() map[string]interface{} {
	if s == nil {
		return nil
	}

	m := make(map[string]interface{})
	if s.PrimaryCoverageRunner != "" {
		m["primaryCoverageRunner"] = s.PrimaryCoverageRunner
	}
	if len(s.Runners) > 0 {
		m["runners"] = s.Runners
	}
	return m
}

// FromMap creates a Spec from a map[string]interface{}.
// This is the main entry point for parsing the spec field from forge.yaml.
func FromMap(m map[string]interface{}) (*Spec, error) {
	return SpecFromMap(m)
}
