// Code generated by forge-dev. DO NOT EDIT.
// Source: spec.openapi.yaml
// SourceChecksum: sha256:daa86fc197bafe82f68bb46f988cb498d7984465681fd82cdd95fa20e4836a60

package main

import (
	"fmt"
)

// Spec represents the Spec configuration.
// Configuration for go-test engine
type Spec struct {
	// Additional arguments to pass to go test (optional)
	Args []string `json:"args,omitempty"`
	// Enable coverage (optional)
	Cover bool `json:"cover,omitempty"`
	// Coverage profile output path (optional)
	Coverprofile string `json:"coverprofile,omitempty"`
	// Environment variables to set for tests (optional)
	Env map[string]string `json:"env,omitempty"`
	// Packages to test (optional, defaults to ./...)
	Packages []string `json:"packages,omitempty"`
	// Enable race detector (optional)
	Race bool `json:"race,omitempty"`
	// Build tags to use (optional)
	Tags []string `json:"tags,omitempty"`
	// Test timeout (optional, e.g., "10m")
	Timeout string `json:"timeout,omitempty"`
}

// SpecFromMap creates a Spec from a map[string]interface{}.
func SpecFromMap(m map[string]interface{}) (*Spec, error) {
	if m == nil {
		return &Spec{}, nil
	}

	s := &Spec{}
	// Parse args
	if v, ok := m["args"]; ok && v != nil {
		if arr, ok := v.([]interface{}); ok {
			s.Args = make([]string, 0, len(arr))
			for i, item := range arr {
				if str, ok := item.(string); ok {
					s.Args = append(s.Args, str)
				} else {
					return nil, fmt.Errorf("field args[%d]: expected string, got %T", i, item)
				}
			}
		} else if arr, ok := v.([]string); ok {
			s.Args = arr
		} else {
			return nil, fmt.Errorf("field args: expected []string, got %T", v)
		}
	}
	// Parse cover
	if v, ok := m["cover"]; ok && v != nil {
		if val, ok := v.(bool); ok {
			s.Cover = val
		} else {
			return nil, fmt.Errorf("field cover: expected bool, got %T", v)
		}
	}
	// Parse coverprofile
	if v, ok := m["coverprofile"]; ok && v != nil {
		if val, ok := v.(string); ok {
			s.Coverprofile = val
		} else {
			return nil, fmt.Errorf("field coverprofile: expected string, got %T", v)
		}
	}
	// Parse env
	if v, ok := m["env"]; ok && v != nil {
		if mapVal, ok := v.(map[string]interface{}); ok {
			s.Env = make(map[string]string, len(mapVal))
			for key, val := range mapVal {
				if str, ok := val.(string); ok {
					s.Env[key] = str
				} else {
					return nil, fmt.Errorf("field env[%s]: expected string, got %T", key, val)
				}
			}
		} else if mapVal, ok := v.(map[string]string); ok {
			s.Env = mapVal
		} else {
			return nil, fmt.Errorf("field env: expected map[string]string, got %T", v)
		}
	}
	// Parse packages
	if v, ok := m["packages"]; ok && v != nil {
		if arr, ok := v.([]interface{}); ok {
			s.Packages = make([]string, 0, len(arr))
			for i, item := range arr {
				if str, ok := item.(string); ok {
					s.Packages = append(s.Packages, str)
				} else {
					return nil, fmt.Errorf("field packages[%d]: expected string, got %T", i, item)
				}
			}
		} else if arr, ok := v.([]string); ok {
			s.Packages = arr
		} else {
			return nil, fmt.Errorf("field packages: expected []string, got %T", v)
		}
	}
	// Parse race
	if v, ok := m["race"]; ok && v != nil {
		if val, ok := v.(bool); ok {
			s.Race = val
		} else {
			return nil, fmt.Errorf("field race: expected bool, got %T", v)
		}
	}
	// Parse tags
	if v, ok := m["tags"]; ok && v != nil {
		if arr, ok := v.([]interface{}); ok {
			s.Tags = make([]string, 0, len(arr))
			for i, item := range arr {
				if str, ok := item.(string); ok {
					s.Tags = append(s.Tags, str)
				} else {
					return nil, fmt.Errorf("field tags[%d]: expected string, got %T", i, item)
				}
			}
		} else if arr, ok := v.([]string); ok {
			s.Tags = arr
		} else {
			return nil, fmt.Errorf("field tags: expected []string, got %T", v)
		}
	}
	// Parse timeout
	if v, ok := m["timeout"]; ok && v != nil {
		if val, ok := v.(string); ok {
			s.Timeout = val
		} else {
			return nil, fmt.Errorf("field timeout: expected string, got %T", v)
		}
	}
	return s, nil
}

// ToMap converts a Spec to a map[string]interface{}.
func (s *Spec) ToMap() map[string]interface{} {
	if s == nil {
		return nil
	}

	m := make(map[string]interface{})
	if len(s.Args) > 0 {
		m["args"] = s.Args
	}
	if s.Cover {
		m["cover"] = s.Cover
	}
	if s.Coverprofile != "" {
		m["coverprofile"] = s.Coverprofile
	}
	if len(s.Env) > 0 {
		m["env"] = s.Env
	}
	if len(s.Packages) > 0 {
		m["packages"] = s.Packages
	}
	if s.Race {
		m["race"] = s.Race
	}
	if len(s.Tags) > 0 {
		m["tags"] = s.Tags
	}
	if s.Timeout != "" {
		m["timeout"] = s.Timeout
	}
	return m
}

// FromMap creates a Spec from a map[string]interface{}.
// This is the main entry point for parsing the spec field from forge.yaml.
func FromMap(m map[string]interface{}) (*Spec, error) {
	return SpecFromMap(m)
}
