// Code generated by forge-dev. DO NOT EDIT.
// Source: spec.openapi.yaml
// SourceChecksum: sha256:4464b4dbd2317db5472a1aa4ee172eff9697c3f614b1c3ac23e5741344986a47

package main

import (
	"github.com/alexandremahdhaoui/forge/pkg/mcptypes"
)

// ValidateSpec validates a Spec and returns validation results.
// It checks required fields and validates enum values.
func ValidateSpec(s *Spec) *mcptypes.ConfigValidateOutput {
	if s == nil {
		return &mcptypes.ConfigValidateOutput{
			Valid: true,
		}
	}

	var errors []mcptypes.ValidationError
	// Validate required array field: builders
	if len(s.Builders) == 0 {
		errors = append(errors, mcptypes.ValidationError{
			Field:   "spec.builders",
			Message: "required field is missing or empty",
		})
	}

	if len(errors) > 0 {
		return &mcptypes.ConfigValidateOutput{
			Valid:  false,
			Errors: errors,
		}
	}

	return &mcptypes.ConfigValidateOutput{
		Valid: true,
	}
}

// Validate validates a Spec and returns validation results.
// This is the main entry point for validation.
func Validate(s *Spec) *mcptypes.ConfigValidateOutput {
	return ValidateSpec(s)
}

// ValidateMap validates a map[string]interface{} by first parsing it to a Spec.
// This is a convenience function for validating spec data from forge.yaml.
func ValidateMap(m map[string]interface{}) *mcptypes.ConfigValidateOutput {
	s, err := FromMap(m)
	if err != nil {
		return &mcptypes.ConfigValidateOutput{
			Valid: false,
			Errors: []mcptypes.ValidationError{
				{
					Field:   "spec",
					Message: err.Error(),
				},
			},
		}
	}

	return Validate(s)
}
