// Code generated by forge-dev. DO NOT EDIT.
// Source: spec.openapi.yaml
// SourceChecksum: sha256:ff055ed90a004dbad73755e405b83056a8932968c7707d598a5fa41bc1a69830

package main

import (
	"context"
	"fmt"

	"github.com/alexandremahdhaoui/forge/pkg/engineframework"
	"github.com/alexandremahdhaoui/forge/pkg/forge"
	"github.com/alexandremahdhaoui/forge/pkg/mcpserver"
	"github.com/alexandremahdhaoui/forge/pkg/mcptypes"
	"github.com/alexandremahdhaoui/forge/pkg/mcputil"
	"github.com/modelcontextprotocol/go-sdk/mcp"
)

// BuildFunc is the signature for the build operation with typed Spec.
// This is the function that engine authors implement.
type BuildFunc func(ctx context.Context, input mcptypes.BuildInput, s *Spec) (*forge.Artifact, error)

// SetupMCPServer creates and configures the MCP server with all required tools.
// It registers build, buildBatch, and config-validate tools.
func SetupMCPServer(name string, version string, buildFn BuildFunc) (*mcpserver.Server, error) {
	server := mcpserver.New(name, version)

	config := engineframework.BuilderConfig{
		Name:      name,
		Version:   version,
		BuildFunc: wrapBuildFunc(buildFn),
	}

	if err := engineframework.RegisterBuilderTools(server, config); err != nil {
		return nil, fmt.Errorf("failed to register builder tools: %w", err)
	}

	// Register config-validate tool
	mcpserver.RegisterTool(server, &mcp.Tool{
		Name:        "config-validate",
		Description: fmt.Sprintf("Validate %s configuration", name),
	}, handleConfigValidate)

	return server, nil
}

// wrapBuildFunc wraps a typed BuildFunc into an engineframework.BuilderFunc.
// It handles parsing and validation of the Spec from the input.
func wrapBuildFunc(fn BuildFunc) engineframework.BuilderFunc {
	return func(ctx context.Context, input mcptypes.BuildInput) (*forge.Artifact, error) {
		// Parse Spec from input
		spec, err := FromMap(input.Spec)
		if err != nil {
			return nil, fmt.Errorf("failed to parse spec: %w", err)
		}

		// Validate Spec
		output := Validate(spec)
		if !output.Valid {
			if len(output.Errors) > 0 {
				return nil, fmt.Errorf("validation failed: %s", output.Errors[0].Message)
			}
			return nil, fmt.Errorf("validation failed")
		}

		// Call the typed build function
		return fn(ctx, input, spec)
	}
}

// handleConfigValidate handles the config-validate MCP tool.
func handleConfigValidate(
	_ context.Context,
	_ *mcp.CallToolRequest,
	input mcptypes.ConfigValidateInput,
) (*mcp.CallToolResult, any, error) {
	output := ValidateMap(input.Spec)

	if output.Valid {
		result, artifact := mcputil.SuccessResultWithArtifact(
			"Configuration is valid",
			output,
		)
		return result, artifact, nil
	}

	result, artifact := mcputil.SuccessResultWithArtifact(
		fmt.Sprintf("Configuration validation failed with %d error(s)", len(output.Errors)),
		output,
	)
	return result, artifact, nil
}
