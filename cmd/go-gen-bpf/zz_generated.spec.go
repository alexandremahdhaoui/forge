// Code generated by forge-dev. DO NOT EDIT.
// Source: spec.openapi.yaml
// SourceChecksum: sha256:ff055ed90a004dbad73755e405b83056a8932968c7707d598a5fa41bc1a69830

package main

import (
	"fmt"
)

// Spec contains the configuration for this engine.
// These fields are populated from the 'spec' field in forge.yaml.
type Spec struct {
	// Version of bpf2go tool (default "latest")
	Bpf2goVersion string `json:"bpf2goVersion,omitempty"`
	// C compiler binary (default bpf2go default)
	Cc string `json:"cc,omitempty"`
	// C compiler flags
	Cflags []string `json:"cflags,omitempty"`
	// Go package name (default basename of dest)
	GoPackage string `json:"goPackage,omitempty"`
	// Go identifier for generated types (required)
	Ident string `json:"ident"`
	// Directory for generated Go code (optional)
	OutputDir string `json:"outputDir,omitempty"`
	// Filename prefix (default "zz_generated")
	OutputStem string `json:"outputStem,omitempty"`
	// Directory containing BPF C source files (optional)
	SourceDir string `json:"sourceDir,omitempty"`
	// Build tags (default ["linux"])
	Tags []string `json:"tags,omitempty"`
	// Specific types to generate (default all)
	Types []string `json:"types,omitempty"`
}

// FromMap creates a Spec from a map[string]interface{}.
// This is used to parse the spec field from forge.yaml.
func FromMap(m map[string]interface{}) (*Spec, error) {
	if m == nil {
		return &Spec{}, nil
	}

	s := &Spec{}

	// Parse bpf2goVersion
	if v, ok := m["bpf2goVersion"]; ok && v != nil {
		if val, ok := v.(string); ok {
			s.Bpf2goVersion = val
		} else {
			return nil, fmt.Errorf("field bpf2goVersion: expected string, got %T", v)
		}
	}

	// Parse cc
	if v, ok := m["cc"]; ok && v != nil {
		if val, ok := v.(string); ok {
			s.Cc = val
		} else {
			return nil, fmt.Errorf("field cc: expected string, got %T", v)
		}
	}

	// Parse cflags
	if v, ok := m["cflags"]; ok && v != nil {
		if arr, ok := v.([]interface{}); ok {
			s.Cflags = make([]string, 0, len(arr))
			for i, item := range arr {
				if str, ok := item.(string); ok {
					s.Cflags = append(s.Cflags, str)
				} else {
					return nil, fmt.Errorf("field cflags[%d]: expected string, got %T", i, item)
				}
			}
		} else if arr, ok := v.([]string); ok {
			s.Cflags = arr
		} else {
			return nil, fmt.Errorf("field cflags: expected []string, got %T", v)
		}
	}

	// Parse goPackage
	if v, ok := m["goPackage"]; ok && v != nil {
		if val, ok := v.(string); ok {
			s.GoPackage = val
		} else {
			return nil, fmt.Errorf("field goPackage: expected string, got %T", v)
		}
	}

	// Parse ident
	if v, ok := m["ident"]; ok && v != nil {
		if val, ok := v.(string); ok {
			s.Ident = val
		} else {
			return nil, fmt.Errorf("field ident: expected string, got %T", v)
		}
	}

	// Parse outputDir
	if v, ok := m["outputDir"]; ok && v != nil {
		if val, ok := v.(string); ok {
			s.OutputDir = val
		} else {
			return nil, fmt.Errorf("field outputDir: expected string, got %T", v)
		}
	}

	// Parse outputStem
	if v, ok := m["outputStem"]; ok && v != nil {
		if val, ok := v.(string); ok {
			s.OutputStem = val
		} else {
			return nil, fmt.Errorf("field outputStem: expected string, got %T", v)
		}
	}

	// Parse sourceDir
	if v, ok := m["sourceDir"]; ok && v != nil {
		if val, ok := v.(string); ok {
			s.SourceDir = val
		} else {
			return nil, fmt.Errorf("field sourceDir: expected string, got %T", v)
		}
	}

	// Parse tags
	if v, ok := m["tags"]; ok && v != nil {
		if arr, ok := v.([]interface{}); ok {
			s.Tags = make([]string, 0, len(arr))
			for i, item := range arr {
				if str, ok := item.(string); ok {
					s.Tags = append(s.Tags, str)
				} else {
					return nil, fmt.Errorf("field tags[%d]: expected string, got %T", i, item)
				}
			}
		} else if arr, ok := v.([]string); ok {
			s.Tags = arr
		} else {
			return nil, fmt.Errorf("field tags: expected []string, got %T", v)
		}
	}

	// Parse types
	if v, ok := m["types"]; ok && v != nil {
		if arr, ok := v.([]interface{}); ok {
			s.Types = make([]string, 0, len(arr))
			for i, item := range arr {
				if str, ok := item.(string); ok {
					s.Types = append(s.Types, str)
				} else {
					return nil, fmt.Errorf("field types[%d]: expected string, got %T", i, item)
				}
			}
		} else if arr, ok := v.([]string); ok {
			s.Types = arr
		} else {
			return nil, fmt.Errorf("field types: expected []string, got %T", v)
		}
	}

	return s, nil
}

// ToMap converts a Spec to a map[string]interface{}.
// This is used for serialization and testing.
func (s *Spec) ToMap() map[string]interface{} {
	if s == nil {
		return nil
	}

	m := make(map[string]interface{})

	if s.Bpf2goVersion != "" {
		m["bpf2goVersion"] = s.Bpf2goVersion
	}

	if s.Cc != "" {
		m["cc"] = s.Cc
	}

	if len(s.Cflags) > 0 {
		m["cflags"] = s.Cflags
	}

	if s.GoPackage != "" {
		m["goPackage"] = s.GoPackage
	}

	if s.Ident != "" {
		m["ident"] = s.Ident
	}

	if s.OutputDir != "" {
		m["outputDir"] = s.OutputDir
	}

	if s.OutputStem != "" {
		m["outputStem"] = s.OutputStem
	}

	if s.SourceDir != "" {
		m["sourceDir"] = s.SourceDir
	}

	if len(s.Tags) > 0 {
		m["tags"] = s.Tags
	}

	if len(s.Types) > 0 {
		m["types"] = s.Types
	}

	return m
}
