//go:build integration

// Copyright 2024 Alexandre Mahdhaoui
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package main

import (
	"context"
	"os"
	"path/filepath"
	"strings"
	"testing"

	"github.com/alexandremahdhaoui/forge/pkg/mcptypes"
)

// createTestGoMod creates a go.mod file in the specified directory.
func createTestGoMod(t *testing.T, dir, modulePath string) {
	t.Helper()
	content := "module " + modulePath + "\n\ngo 1.21\n"
	if err := os.WriteFile(filepath.Join(dir, "go.mod"), []byte(content), 0o644); err != nil {
		t.Fatalf("writing go.mod: %v", err)
	}
}

// createTestEngineDir creates the cmd/my-engine directory structure with required files.
func createTestEngineDir(t *testing.T, projectRoot, engineName string, specTypesConfig string) string {
	t.Helper()

	// Create cmd/my-engine directory
	engineDir := filepath.Join(projectRoot, "cmd", engineName)
	if err := os.MkdirAll(engineDir, 0o755); err != nil {
		t.Fatalf("creating engine dir: %v", err)
	}

	// Create forge-dev.yaml with optional specTypes config
	configContent := `name: ` + engineName + `
type: builder
version: 0.1.0
description: Test engine for integration tests
openapi:
  specPath: ./spec.openapi.yaml
generate:
  packageName: main
` + specTypesConfig

	if err := os.WriteFile(filepath.Join(engineDir, "forge-dev.yaml"), []byte(configContent), 0o644); err != nil {
		t.Fatalf("writing forge-dev.yaml: %v", err)
	}

	// Create spec.openapi.yaml
	specContent := `openapi: 3.0.3
info:
  title: ` + engineName + ` Spec Schema
  version: 0.1.0
components:
  schemas:
    Spec:
      type: object
      properties:
        name:
          type: string
          description: The engine name
        enabled:
          type: boolean
          description: Whether the engine is enabled
      required:
        - name
`
	if err := os.WriteFile(filepath.Join(engineDir, "spec.openapi.yaml"), []byte(specContent), 0o644); err != nil {
		t.Fatalf("writing spec.openapi.yaml: %v", err)
	}

	// Create docs/usage.md
	docsDir := filepath.Join(engineDir, "docs")
	if err := os.MkdirAll(docsDir, 0o755); err != nil {
		t.Fatalf("creating docs dir: %v", err)
	}
	if err := os.WriteFile(filepath.Join(docsDir, "usage.md"), []byte("# Usage\n\nTest usage documentation.\n"), 0o644); err != nil {
		t.Fatalf("writing docs/usage.md: %v", err)
	}

	return engineDir
}

// TestGenerateWithSpecTypes tests the full generation workflow with specTypes enabled.
func TestGenerateWithSpecTypes(t *testing.T) {
	t.Run("generates spec types to external package", func(t *testing.T) {
		// Create temp directory structure
		tmpDir := t.TempDir()

		// Create go.mod
		createTestGoMod(t, tmpDir, "github.com/test/project")

		// Create engine directory with specTypes enabled
		specTypesConfig := `  specTypes:
    enabled: true
    outputPath: pkg/api/v1
    packageName: v1
`
		engineDir := createTestEngineDir(t, tmpDir, "my-engine", specTypesConfig)

		// Run generate
		ctx := context.Background()
		input := mcptypes.BuildInput{
			Name:   "my-engine",
			Src:    engineDir,
			Engine: "go://forge-dev",
		}

		artifact, err := generate(ctx, input)
		if err != nil {
			t.Fatalf("generate() error: %v", err)
		}

		// Verify artifact
		if artifact.Name != "my-engine" {
			t.Errorf("artifact.Name = %q, want %q", artifact.Name, "my-engine")
		}
		if artifact.Type != "generated" {
			t.Errorf("artifact.Type = %q, want %q", artifact.Type, "generated")
		}

		// Verify spec.go is created in the external package path
		specFilePath := filepath.Join(tmpDir, "pkg", "api", "v1", GeneratedSpecFile)
		specContent, err := os.ReadFile(specFilePath)
		if err != nil {
			t.Fatalf("reading generated spec file from external path: %v", err)
		}

		// Verify spec.go has the correct package declaration
		if !strings.Contains(string(specContent), "package v1") {
			t.Errorf("spec.go should have 'package v1', got:\n%s", string(specContent))
		}

		// Verify spec.go contains checksum header
		if !strings.Contains(string(specContent), artifact.Version) {
			t.Error("spec.go does not contain checksum header")
		}
		if !strings.Contains(string(specContent), "// Code generated by forge-dev. DO NOT EDIT.") {
			t.Error("spec.go does not contain generated header")
		}

		// Verify validate.go is in srcDir with import for spec types
		validateFilePath := filepath.Join(engineDir, GeneratedValidateFile)
		validateContent, err := os.ReadFile(validateFilePath)
		if err != nil {
			t.Fatalf("reading generated validate file: %v", err)
		}

		// Check validate.go imports the spec types package
		if !strings.Contains(string(validateContent), `v1 "github.com/test/project/pkg/api/v1"`) {
			t.Errorf("validate.go should import spec types package, got:\n%s", string(validateContent))
		}

		// Verify mcp.go is in srcDir with import for spec types
		mcpFilePath := filepath.Join(engineDir, GeneratedMCPFile)
		mcpContent, err := os.ReadFile(mcpFilePath)
		if err != nil {
			t.Fatalf("reading generated mcp file: %v", err)
		}

		// Check mcp.go imports the spec types package
		if !strings.Contains(string(mcpContent), `v1 "github.com/test/project/pkg/api/v1"`) {
			t.Errorf("mcp.go should import spec types package, got:\n%s", string(mcpContent))
		}

		// Verify main.go is in srcDir with import for spec types
		mainFilePath := filepath.Join(engineDir, GeneratedMainFile)
		mainContent, err := os.ReadFile(mainFilePath)
		if err != nil {
			t.Fatalf("reading generated main file: %v", err)
		}

		// Check main.go imports the spec types package
		if !strings.Contains(string(mainContent), `v1 "github.com/test/project/pkg/api/v1"`) {
			t.Errorf("main.go should import spec types package, got:\n%s", string(mainContent))
		}

		// Verify all files have checksum header
		for name, content := range map[string][]byte{
			"spec.go":     specContent,
			"validate.go": validateContent,
			"mcp.go":      mcpContent,
			"main.go":     mainContent,
		} {
			if !strings.Contains(string(content), artifact.Version) {
				t.Errorf("%s does not contain checksum header", name)
			}
		}
	})

	t.Run("backward compatibility without specTypes", func(t *testing.T) {
		// Create temp directory structure
		tmpDir := t.TempDir()

		// Create go.mod
		createTestGoMod(t, tmpDir, "github.com/test/project")

		// Create engine directory WITHOUT specTypes config
		engineDir := createTestEngineDir(t, tmpDir, "legacy-engine", "")

		// Run generate
		ctx := context.Background()
		input := mcptypes.BuildInput{
			Name:   "legacy-engine",
			Src:    engineDir,
			Engine: "go://forge-dev",
		}

		artifact, err := generate(ctx, input)
		if err != nil {
			t.Fatalf("generate() error: %v", err)
		}

		// Verify all files are in srcDir (not in external path)
		for _, fileName := range []string{GeneratedSpecFile, GeneratedValidateFile, GeneratedMCPFile, GeneratedMainFile} {
			path := filepath.Join(engineDir, fileName)
			if _, err := os.Stat(path); os.IsNotExist(err) {
				t.Errorf("generated file %s does not exist in srcDir", fileName)
			}
		}

		// Verify spec.go has package main (not external package)
		specFilePath := filepath.Join(engineDir, GeneratedSpecFile)
		specContent, err := os.ReadFile(specFilePath)
		if err != nil {
			t.Fatalf("reading generated spec file: %v", err)
		}

		if !strings.Contains(string(specContent), "package main") {
			t.Errorf("spec.go should have 'package main' in backward compatible mode, got:\n%s", string(specContent))
		}

		// Verify validate.go does NOT import external spec types
		validateFilePath := filepath.Join(engineDir, GeneratedValidateFile)
		validateContent, err := os.ReadFile(validateFilePath)
		if err != nil {
			t.Fatalf("reading generated validate file: %v", err)
		}

		// Should not have an import for v1 package
		if strings.Contains(string(validateContent), `v1 "github.com/test/project/`) {
			t.Errorf("validate.go should not import external spec types in backward compatible mode")
		}

		// Verify artifact
		if artifact.Name != "legacy-engine" {
			t.Errorf("artifact.Name = %q, want %q", artifact.Name, "legacy-engine")
		}
	})

	t.Run("nested output path creates all directories", func(t *testing.T) {
		// Create temp directory structure
		tmpDir := t.TempDir()

		// Create go.mod
		createTestGoMod(t, tmpDir, "github.com/test/project")

		// Create engine directory with deeply nested specTypes path
		specTypesConfig := `  specTypes:
    enabled: true
    outputPath: pkg/api/v1/alpha
    packageName: alpha
`
		engineDir := createTestEngineDir(t, tmpDir, "nested-engine", specTypesConfig)

		// Run generate
		ctx := context.Background()
		input := mcptypes.BuildInput{
			Name:   "nested-engine",
			Src:    engineDir,
			Engine: "go://forge-dev",
		}

		artifact, err := generate(ctx, input)
		if err != nil {
			t.Fatalf("generate() error: %v", err)
		}

		// Verify all nested directories are created and spec.go exists there
		specFilePath := filepath.Join(tmpDir, "pkg", "api", "v1", "alpha", GeneratedSpecFile)
		specContent, err := os.ReadFile(specFilePath)
		if err != nil {
			t.Fatalf("reading generated spec file from nested path: %v", err)
		}

		// Verify spec.go has the correct package declaration
		if !strings.Contains(string(specContent), "package alpha") {
			t.Errorf("spec.go should have 'package alpha', got:\n%s", string(specContent))
		}

		// Verify validate.go imports the nested package correctly
		validateFilePath := filepath.Join(engineDir, GeneratedValidateFile)
		validateContent, err := os.ReadFile(validateFilePath)
		if err != nil {
			t.Fatalf("reading generated validate file: %v", err)
		}

		if !strings.Contains(string(validateContent), `alpha "github.com/test/project/pkg/api/v1/alpha"`) {
			t.Errorf("validate.go should import nested spec types package, got:\n%s", string(validateContent))
		}

		// Verify artifact
		if artifact.Name != "nested-engine" {
			t.Errorf("artifact.Name = %q, want %q", artifact.Name, "nested-engine")
		}
		if !strings.HasPrefix(artifact.Version, "sha256:") {
			t.Errorf("artifact.Version = %q, want sha256: prefix", artifact.Version)
		}
	})

	t.Run("checksum skip works with external spec path", func(t *testing.T) {
		// Create temp directory structure
		tmpDir := t.TempDir()

		// Create go.mod
		createTestGoMod(t, tmpDir, "github.com/test/project")

		// Create engine directory with specTypes enabled
		specTypesConfig := `  specTypes:
    enabled: true
    outputPath: pkg/api/v1
    packageName: v1
`
		engineDir := createTestEngineDir(t, tmpDir, "checksum-engine", specTypesConfig)

		ctx := context.Background()
		input := mcptypes.BuildInput{
			Name:   "checksum-engine",
			Src:    engineDir,
			Engine: "go://forge-dev",
		}

		// First run
		artifact1, err := generate(ctx, input)
		if err != nil {
			t.Fatalf("first generate() error: %v", err)
		}

		// Get file modification time of spec file in external path
		specPath := filepath.Join(tmpDir, "pkg", "api", "v1", GeneratedSpecFile)
		stat1, err := os.Stat(specPath)
		if err != nil {
			t.Fatalf("stat generated spec file: %v", err)
		}

		// Second run (should skip regeneration)
		artifact2, err := generate(ctx, input)
		if err != nil {
			t.Fatalf("second generate() error: %v", err)
		}

		// Verify same checksum
		if artifact1.Version != artifact2.Version {
			t.Errorf("checksums differ: %q vs %q", artifact1.Version, artifact2.Version)
		}

		// Verify file not modified (skipped)
		stat2, err := os.Stat(specPath)
		if err != nil {
			t.Fatalf("stat generated spec file after second run: %v", err)
		}
		if !stat1.ModTime().Equal(stat2.ModTime()) {
			t.Error("spec file was modified when it should have been skipped")
		}
	})

	t.Run("force flag regenerates with external spec path", func(t *testing.T) {
		// Create temp directory structure
		tmpDir := t.TempDir()

		// Create go.mod
		createTestGoMod(t, tmpDir, "github.com/test/project")

		// Create engine directory with specTypes enabled
		specTypesConfig := `  specTypes:
    enabled: true
    outputPath: pkg/api/v1
    packageName: v1
`
		engineDir := createTestEngineDir(t, tmpDir, "force-engine", specTypesConfig)

		ctx := context.Background()
		input := mcptypes.BuildInput{
			Name:   "force-engine",
			Src:    engineDir,
			Engine: "go://forge-dev",
		}

		// First run
		_, err := generate(ctx, input)
		if err != nil {
			t.Fatalf("first generate() error: %v", err)
		}

		// Get file modification time of spec file in external path
		specPath := filepath.Join(tmpDir, "pkg", "api", "v1", GeneratedSpecFile)
		stat1, err := os.Stat(specPath)
		if err != nil {
			t.Fatalf("stat generated spec file: %v", err)
		}

		// Modify the file content slightly to ensure we can detect a rewrite
		// (in practice the mtime will change on regeneration)
		originalContent, err := os.ReadFile(specPath)
		if err != nil {
			t.Fatalf("reading spec file: %v", err)
		}

		// Second run with force flag
		inputForce := mcptypes.BuildInput{
			Name:   "force-engine",
			Src:    engineDir,
			Engine: "go://forge-dev",
			Force:  true,
		}

		_, err = generate(ctx, inputForce)
		if err != nil {
			t.Fatalf("second generate() with force error: %v", err)
		}

		// Verify file was regenerated
		stat2, err := os.Stat(specPath)
		if err != nil {
			t.Fatalf("stat generated spec file after force run: %v", err)
		}

		// File should have been modified OR at least not be older than the first run
		// (mod time should be >= first run since we forced regeneration)
		if stat2.ModTime().Before(stat1.ModTime()) {
			t.Error("spec file should have been regenerated with force flag")
		}

		// Verify content is the same (same checksum should produce same content)
		newContent, err := os.ReadFile(specPath)
		if err != nil {
			t.Fatalf("reading spec file after force: %v", err)
		}

		if string(originalContent) != string(newContent) {
			t.Error("spec file content should be the same after forced regeneration")
		}
	})

	t.Run("multi-level module path resolution", func(t *testing.T) {
		// Create temp directory structure
		tmpDir := t.TempDir()

		// Create go.mod with a multi-level module path
		createTestGoMod(t, tmpDir, "github.com/org/project/submodule")

		// Create engine directory with specTypes enabled
		specTypesConfig := `  specTypes:
    enabled: true
    outputPath: pkg/api/v1
    packageName: v1
`
		engineDir := createTestEngineDir(t, tmpDir, "multi-module-engine", specTypesConfig)

		// Run generate
		ctx := context.Background()
		input := mcptypes.BuildInput{
			Name:   "multi-module-engine",
			Src:    engineDir,
			Engine: "go://forge-dev",
		}

		artifact, err := generate(ctx, input)
		if err != nil {
			t.Fatalf("generate() error: %v", err)
		}

		// Verify validate.go imports with full module path
		validateFilePath := filepath.Join(engineDir, GeneratedValidateFile)
		validateContent, err := os.ReadFile(validateFilePath)
		if err != nil {
			t.Fatalf("reading generated validate file: %v", err)
		}

		expectedImport := `v1 "github.com/org/project/submodule/pkg/api/v1"`
		if !strings.Contains(string(validateContent), expectedImport) {
			t.Errorf("validate.go should import with full module path %q, got:\n%s", expectedImport, string(validateContent))
		}

		// Verify artifact
		if artifact.Name != "multi-module-engine" {
			t.Errorf("artifact.Name = %q, want %q", artifact.Name, "multi-module-engine")
		}
	})

	t.Run("output path with leading dot-slash", func(t *testing.T) {
		// Create temp directory structure
		tmpDir := t.TempDir()

		// Create go.mod
		createTestGoMod(t, tmpDir, "github.com/test/project")

		// Create engine directory with outputPath starting with ./
		specTypesConfig := `  specTypes:
    enabled: true
    outputPath: ./pkg/api/v1
    packageName: v1
`
		engineDir := createTestEngineDir(t, tmpDir, "dotslash-engine", specTypesConfig)

		// Run generate
		ctx := context.Background()
		input := mcptypes.BuildInput{
			Name:   "dotslash-engine",
			Src:    engineDir,
			Engine: "go://forge-dev",
		}

		artifact, err := generate(ctx, input)
		if err != nil {
			t.Fatalf("generate() error: %v", err)
		}

		// Verify spec.go is created in the correct path (cleaned)
		specFilePath := filepath.Join(tmpDir, "pkg", "api", "v1", GeneratedSpecFile)
		if _, err := os.Stat(specFilePath); os.IsNotExist(err) {
			t.Errorf("spec.go should exist at %s", specFilePath)
		}

		// Verify artifact
		if artifact.Name != "dotslash-engine" {
			t.Errorf("artifact.Name = %q, want %q", artifact.Name, "dotslash-engine")
		}
	})
}

// TestGenerateWithSpecTypes_NestedTypes tests generation with nested/referenced types.
func TestGenerateWithSpecTypes_NestedTypes(t *testing.T) {
	// Create temp directory structure
	tmpDir := t.TempDir()

	// Create go.mod
	createTestGoMod(t, tmpDir, "github.com/test/project")

	// Create cmd/my-engine directory
	engineDir := filepath.Join(tmpDir, "cmd", "my-engine")
	if err := os.MkdirAll(engineDir, 0o755); err != nil {
		t.Fatalf("creating engine dir: %v", err)
	}

	// Create forge-dev.yaml with specTypes
	configContent := `name: nested-types-engine
type: builder
version: 0.1.0
description: Test engine with nested types
openapi:
  specPath: ./spec.openapi.yaml
generate:
  packageName: main
  specTypes:
    enabled: true
    outputPath: pkg/api/v1
    packageName: v1
`
	if err := os.WriteFile(filepath.Join(engineDir, "forge-dev.yaml"), []byte(configContent), 0o644); err != nil {
		t.Fatalf("writing forge-dev.yaml: %v", err)
	}

	// Create spec.openapi.yaml with nested types
	specContent := `openapi: 3.0.3
info:
  title: nested-types-engine Spec Schema
  version: 0.1.0
components:
  schemas:
    VMResource:
      type: object
      properties:
        cpu:
          type: integer
          description: Number of CPUs
        memory:
          type: string
          description: Memory size (e.g., "4Gi")
      required:
        - cpu
        - memory
    Spec:
      type: object
      properties:
        name:
          type: string
          description: The engine name
        resources:
          $ref: '#/components/schemas/VMResource'
        tags:
          type: array
          items:
            type: string
          description: List of tags
      required:
        - name
`
	if err := os.WriteFile(filepath.Join(engineDir, "spec.openapi.yaml"), []byte(specContent), 0o644); err != nil {
		t.Fatalf("writing spec.openapi.yaml: %v", err)
	}

	// Create docs/usage.md
	docsDir := filepath.Join(engineDir, "docs")
	if err := os.MkdirAll(docsDir, 0o755); err != nil {
		t.Fatalf("creating docs dir: %v", err)
	}
	if err := os.WriteFile(filepath.Join(docsDir, "usage.md"), []byte("# Usage\n\nTest usage.\n"), 0o644); err != nil {
		t.Fatalf("writing docs/usage.md: %v", err)
	}

	// Run generate
	ctx := context.Background()
	input := mcptypes.BuildInput{
		Name:   "nested-types-engine",
		Src:    engineDir,
		Engine: "go://forge-dev",
	}

	artifact, err := generate(ctx, input)
	if err != nil {
		t.Fatalf("generate() error: %v", err)
	}

	// Verify spec.go is in the external package
	specFilePath := filepath.Join(tmpDir, "pkg", "api", "v1", GeneratedSpecFile)
	specContent2, err := os.ReadFile(specFilePath)
	if err != nil {
		t.Fatalf("reading generated spec file: %v", err)
	}

	// Verify VMResource type is generated
	if !strings.Contains(string(specContent2), "type VMResource struct") {
		t.Errorf("spec.go should contain VMResource type, got:\n%s", string(specContent2))
	}

	// Verify Spec type references VMResource
	if !strings.Contains(string(specContent2), "Resources VMResource") {
		t.Errorf("spec.go should contain Resources field of type VMResource, got:\n%s", string(specContent2))
	}

	// Verify Tags array
	if !strings.Contains(string(specContent2), "Tags []string") {
		t.Errorf("spec.go should contain Tags field of type []string, got:\n%s", string(specContent2))
	}

	// Verify package name
	if !strings.Contains(string(specContent2), "package v1") {
		t.Errorf("spec.go should have 'package v1', got:\n%s", string(specContent2))
	}

	// Verify validate.go references types correctly
	validateFilePath := filepath.Join(engineDir, GeneratedValidateFile)
	validateContent, err := os.ReadFile(validateFilePath)
	if err != nil {
		t.Fatalf("reading generated validate file: %v", err)
	}

	// Check that validate.go has qualified type references
	if !strings.Contains(string(validateContent), "*v1.Spec") {
		t.Errorf("validate.go should reference *v1.Spec, got:\n%s", string(validateContent))
	}

	// Verify artifact
	if artifact.Name != "nested-types-engine" {
		t.Errorf("artifact.Name = %q, want %q", artifact.Name, "nested-types-engine")
	}
}
