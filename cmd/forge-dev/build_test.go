//go:build unit

// Copyright 2024 Alexandre Mahdhaoui
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package main

import (
	"context"
	"os"
	"path/filepath"
	"strings"
	"testing"

	"github.com/alexandremahdhaoui/forge/pkg/mcptypes"
)

// createRequiredDocs creates the required docs/usage.md file in the temp directory.
func createRequiredDocs(t *testing.T, tmpDir string) {
	t.Helper()
	docsDir := filepath.Join(tmpDir, "docs")
	if err := os.MkdirAll(docsDir, 0o755); err != nil {
		t.Fatalf("creating docs dir: %v", err)
	}
	if err := os.WriteFile(filepath.Join(docsDir, "usage.md"), []byte("# Usage\n\nTest usage doc.\n"), 0o644); err != nil {
		t.Fatalf("writing docs/usage.md: %v", err)
	}
}

func TestGenerate(t *testing.T) {
	t.Run("generates all three files", func(t *testing.T) {
		// Create temp directory with test files
		tmpDir := t.TempDir()

		// Create required docs/usage.md
		createRequiredDocs(t, tmpDir)

		// Create forge-dev.yaml
		configContent := `name: test-engine
type: builder
version: 0.1.0
description: Test engine for unit tests
openapi:
  specPath: ./spec.openapi.yaml
generate:
  packageName: main
`
		if err := os.WriteFile(filepath.Join(tmpDir, "forge-dev.yaml"), []byte(configContent), 0o644); err != nil {
			t.Fatalf("writing forge-dev.yaml: %v", err)
		}

		// Create spec.openapi.yaml
		specContent := `openapi: 3.0.3
info:
  title: test-engine Spec Schema
  version: 0.1.0
components:
  schemas:
    Spec:
      type: object
      properties:
        stringField:
          type: string
          description: A string field
        boolField:
          type: boolean
          description: A boolean field
        intField:
          type: integer
          description: An integer field
        stringArray:
          type: array
          items:
            type: string
          description: An array of strings
        stringMap:
          type: object
          additionalProperties:
            type: string
          description: A map of string to string
      required:
        - stringField
`
		if err := os.WriteFile(filepath.Join(tmpDir, "spec.openapi.yaml"), []byte(specContent), 0o644); err != nil {
			t.Fatalf("writing spec.openapi.yaml: %v", err)
		}

		// Run generate
		ctx := context.Background()
		input := mcptypes.BuildInput{
			Name:   "test-engine",
			Src:    tmpDir,
			Engine: "go://forge-dev",
		}

		artifact, err := generate(ctx, input)
		if err != nil {
			t.Fatalf("generate() error: %v", err)
		}

		// Verify artifact
		if artifact.Name != "test-engine" {
			t.Errorf("artifact.Name = %q, want %q", artifact.Name, "test-engine")
		}
		if artifact.Type != "generated" {
			t.Errorf("artifact.Type = %q, want %q", artifact.Type, "generated")
		}
		if artifact.Location != tmpDir {
			t.Errorf("artifact.Location = %q, want %q", artifact.Location, tmpDir)
		}
		if !strings.HasPrefix(artifact.Version, "sha256:") {
			t.Errorf("artifact.Version = %q, want sha256: prefix", artifact.Version)
		}

		// Verify generated files exist
		for _, fileName := range []string{GeneratedSpecFile, GeneratedValidateFile, GeneratedMCPFile} {
			path := filepath.Join(tmpDir, fileName)
			if _, err := os.Stat(path); os.IsNotExist(err) {
				t.Errorf("generated file %s does not exist", fileName)
			}
		}

		// Verify generated files contain correct checksum
		specFileContent, err := os.ReadFile(filepath.Join(tmpDir, GeneratedSpecFile))
		if err != nil {
			t.Fatalf("reading generated spec file: %v", err)
		}
		if !strings.Contains(string(specFileContent), artifact.Version) {
			t.Error("generated spec file does not contain checksum")
		}
		if !strings.Contains(string(specFileContent), "// Code generated by forge-dev. DO NOT EDIT.") {
			t.Error("generated spec file does not contain header")
		}
	})

	t.Run("skips regeneration when checksums match", func(t *testing.T) {
		// Create temp directory with test files
		tmpDir := t.TempDir()

		// Create required docs/usage.md
		createRequiredDocs(t, tmpDir)

		// Create forge-dev.yaml
		configContent := `name: idempotent-engine
type: builder
version: 0.1.0
openapi:
  specPath: ./spec.openapi.yaml
generate:
  packageName: main
`
		if err := os.WriteFile(filepath.Join(tmpDir, "forge-dev.yaml"), []byte(configContent), 0o644); err != nil {
			t.Fatalf("writing forge-dev.yaml: %v", err)
		}

		// Create spec.openapi.yaml
		specContent := `openapi: 3.0.3
info:
  title: idempotent-engine Spec Schema
  version: 0.1.0
components:
  schemas:
    Spec:
      type: object
      properties:
        field:
          type: string
`
		if err := os.WriteFile(filepath.Join(tmpDir, "spec.openapi.yaml"), []byte(specContent), 0o644); err != nil {
			t.Fatalf("writing spec.openapi.yaml: %v", err)
		}

		ctx := context.Background()
		input := mcptypes.BuildInput{
			Name:   "idempotent-engine",
			Src:    tmpDir,
			Engine: "go://forge-dev",
		}

		// First run
		artifact1, err := generate(ctx, input)
		if err != nil {
			t.Fatalf("first generate() error: %v", err)
		}

		// Get file modification time
		specPath := filepath.Join(tmpDir, GeneratedSpecFile)
		stat1, err := os.Stat(specPath)
		if err != nil {
			t.Fatalf("stat generated file: %v", err)
		}

		// Second run (should skip regeneration)
		artifact2, err := generate(ctx, input)
		if err != nil {
			t.Fatalf("second generate() error: %v", err)
		}

		// Verify same checksum
		if artifact1.Version != artifact2.Version {
			t.Errorf("checksums differ: %q vs %q", artifact1.Version, artifact2.Version)
		}

		// Verify file not modified (skipped)
		stat2, err := os.Stat(specPath)
		if err != nil {
			t.Fatalf("stat generated file after second run: %v", err)
		}
		if !stat1.ModTime().Equal(stat2.ModTime()) {
			t.Error("file was modified when it should have been skipped")
		}
	})

	t.Run("errors on missing src directory", func(t *testing.T) {
		ctx := context.Background()
		input := mcptypes.BuildInput{
			Name:   "test",
			Src:    "",
			Engine: "go://forge-dev",
		}

		_, err := generate(ctx, input)
		if err == nil {
			t.Fatal("expected error for missing src directory")
		}
		if !strings.Contains(err.Error(), "src directory is required") {
			t.Errorf("unexpected error: %v", err)
		}
	})

	t.Run("errors on missing forge-dev.yaml", func(t *testing.T) {
		tmpDir := t.TempDir()
		ctx := context.Background()
		input := mcptypes.BuildInput{
			Name:   "test",
			Src:    tmpDir,
			Engine: "go://forge-dev",
		}

		_, err := generate(ctx, input)
		if err == nil {
			t.Fatal("expected error for missing forge-dev.yaml")
		}
		if !strings.Contains(err.Error(), "forge-dev.yaml") {
			t.Errorf("unexpected error: %v", err)
		}
	})

	t.Run("errors on invalid forge-dev.yaml", func(t *testing.T) {
		tmpDir := t.TempDir()

		// Create invalid forge-dev.yaml (missing required fields)
		configContent := `name: ""
type: invalid-type
version: not-semver
`
		if err := os.WriteFile(filepath.Join(tmpDir, "forge-dev.yaml"), []byte(configContent), 0o644); err != nil {
			t.Fatalf("writing forge-dev.yaml: %v", err)
		}

		ctx := context.Background()
		input := mcptypes.BuildInput{
			Name:   "test",
			Src:    tmpDir,
			Engine: "go://forge-dev",
		}

		_, err := generate(ctx, input)
		if err == nil {
			t.Fatal("expected error for invalid forge-dev.yaml")
		}
		if !strings.Contains(err.Error(), "invalid forge-dev.yaml") {
			t.Errorf("unexpected error: %v", err)
		}
	})

	t.Run("errors on missing spec.openapi.yaml", func(t *testing.T) {
		tmpDir := t.TempDir()

		// Create required docs/usage.md
		createRequiredDocs(t, tmpDir)

		// Create valid forge-dev.yaml
		configContent := `name: test-engine
type: builder
version: 0.1.0
openapi:
  specPath: ./spec.openapi.yaml
generate:
  packageName: main
`
		if err := os.WriteFile(filepath.Join(tmpDir, "forge-dev.yaml"), []byte(configContent), 0o644); err != nil {
			t.Fatalf("writing forge-dev.yaml: %v", err)
		}

		ctx := context.Background()
		input := mcptypes.BuildInput{
			Name:   "test",
			Src:    tmpDir,
			Engine: "go://forge-dev",
		}

		_, err := generate(ctx, input)
		if err == nil {
			t.Fatal("expected error for missing spec.openapi.yaml")
		}
		if !strings.Contains(err.Error(), "checksum") || !strings.Contains(err.Error(), "spec") {
			t.Errorf("unexpected error: %v", err)
		}
	})
}

func TestGenerateTestRunnerType(t *testing.T) {
	t.Run("generates test-runner MCP template", func(t *testing.T) {
		tmpDir := t.TempDir()

		// Create required docs/usage.md
		createRequiredDocs(t, tmpDir)

		// Create forge-dev.yaml for test-runner
		configContent := `name: test-runner-engine
type: test-runner
version: 0.1.0
openapi:
  specPath: ./spec.openapi.yaml
generate:
  packageName: main
`
		if err := os.WriteFile(filepath.Join(tmpDir, "forge-dev.yaml"), []byte(configContent), 0o644); err != nil {
			t.Fatalf("writing forge-dev.yaml: %v", err)
		}

		// Create spec.openapi.yaml
		specContent := `openapi: 3.0.3
info:
  title: test-runner-engine Spec Schema
  version: 0.1.0
components:
  schemas:
    Spec:
      type: object
      properties:
        verbose:
          type: boolean
`
		if err := os.WriteFile(filepath.Join(tmpDir, "spec.openapi.yaml"), []byte(specContent), 0o644); err != nil {
			t.Fatalf("writing spec.openapi.yaml: %v", err)
		}

		ctx := context.Background()
		input := mcptypes.BuildInput{
			Name:   "test-runner-engine",
			Src:    tmpDir,
			Engine: "go://forge-dev",
		}

		artifact, err := generate(ctx, input)
		if err != nil {
			t.Fatalf("generate() error: %v", err)
		}

		// Verify MCP file contains test-runner specific code
		mcpContent, err := os.ReadFile(filepath.Join(tmpDir, GeneratedMCPFile))
		if err != nil {
			t.Fatalf("reading generated mcp file: %v", err)
		}
		if !strings.Contains(string(mcpContent), "TestRunnerFunc") {
			t.Error("generated mcp file does not contain TestRunnerFunc for test-runner type")
		}

		if artifact.Name != "test-runner-engine" {
			t.Errorf("artifact.Name = %q, want %q", artifact.Name, "test-runner-engine")
		}
	})
}

func TestGenerateTestEnvSubengineType(t *testing.T) {
	t.Run("generates testenv-subengine MCP template", func(t *testing.T) {
		tmpDir := t.TempDir()

		// Create required docs/usage.md
		createRequiredDocs(t, tmpDir)

		// Create forge-dev.yaml for testenv-subengine
		configContent := `name: testenv-subengine-engine
type: testenv-subengine
version: 0.1.0
openapi:
  specPath: ./spec.openapi.yaml
generate:
  packageName: main
`
		if err := os.WriteFile(filepath.Join(tmpDir, "forge-dev.yaml"), []byte(configContent), 0o644); err != nil {
			t.Fatalf("writing forge-dev.yaml: %v", err)
		}

		// Create spec.openapi.yaml
		specContent := `openapi: 3.0.3
info:
  title: testenv-subengine-engine Spec Schema
  version: 0.1.0
components:
  schemas:
    Spec:
      type: object
      properties:
        enabled:
          type: boolean
`
		if err := os.WriteFile(filepath.Join(tmpDir, "spec.openapi.yaml"), []byte(specContent), 0o644); err != nil {
			t.Fatalf("writing spec.openapi.yaml: %v", err)
		}

		ctx := context.Background()
		input := mcptypes.BuildInput{
			Name:   "testenv-subengine-engine",
			Src:    tmpDir,
			Engine: "go://forge-dev",
		}

		artifact, err := generate(ctx, input)
		if err != nil {
			t.Fatalf("generate() error: %v", err)
		}

		// Verify MCP file contains testenv-subengine specific code
		mcpContent, err := os.ReadFile(filepath.Join(tmpDir, GeneratedMCPFile))
		if err != nil {
			t.Fatalf("reading generated mcp file: %v", err)
		}
		if !strings.Contains(string(mcpContent), "CreateFunc") {
			t.Error("generated mcp file does not contain CreateFunc for testenv-subengine type")
		}
		if !strings.Contains(string(mcpContent), "DeleteFunc") {
			t.Error("generated mcp file does not contain DeleteFunc for testenv-subengine type")
		}

		if artifact.Name != "testenv-subengine-engine" {
			t.Errorf("artifact.Name = %q, want %q", artifact.Name, "testenv-subengine-engine")
		}
	})
}
