// Code generated by forge-dev. DO NOT EDIT.
// Source: spec.openapi.yaml
{{.ChecksumHeader}}

package {{.PackageName}}

{{if .Properties}}
import (
	"fmt"
)
{{end}}

// Spec contains the configuration for this engine.
// These fields are populated from the 'spec' field in forge.yaml.
type Spec struct {
{{- range .Properties}}
	// {{.Description}}
	{{.Name | camel}} {{.GoType}} {{jsonTag .Name .Required}}
{{- end}}
}

// FromMap creates a Spec from a map[string]interface{}.
// This is used to parse the spec field from forge.yaml.
func FromMap(m map[string]interface{}) (*Spec, error) {
	if m == nil {
		return &Spec{}, nil
	}

	s := &Spec{}
{{range .Properties}}
	// Parse {{.Name}}
	if v, ok := m["{{.Name}}"]; ok && v != nil {
{{- if eq .GoType "string"}}
		if val, ok := v.(string); ok {
			s.{{.Name | camel}} = val
		} else {
			return nil, fmt.Errorf("field {{.Name}}: expected string, got %T", v)
		}
{{- else if eq .GoType "bool"}}
		if val, ok := v.(bool); ok {
			s.{{.Name | camel}} = val
		} else {
			return nil, fmt.Errorf("field {{.Name}}: expected bool, got %T", v)
		}
{{- else if eq .GoType "int"}}
		switch val := v.(type) {
		case int:
			s.{{.Name | camel}} = val
		case int64:
			s.{{.Name | camel}} = int(val)
		case float64:
			s.{{.Name | camel}} = int(val)
		default:
			return nil, fmt.Errorf("field {{.Name}}: expected int, got %T", v)
		}
{{- else if eq .GoType "float64"}}
		switch val := v.(type) {
		case float64:
			s.{{.Name | camel}} = val
		case int:
			s.{{.Name | camel}} = float64(val)
		case int64:
			s.{{.Name | camel}} = float64(val)
		default:
			return nil, fmt.Errorf("field {{.Name}}: expected float64, got %T", v)
		}
{{- else if eq .GoType "[]string"}}
		if arr, ok := v.([]interface{}); ok {
			s.{{.Name | camel}} = make([]string, 0, len(arr))
			for i, item := range arr {
				if str, ok := item.(string); ok {
					s.{{.Name | camel}} = append(s.{{.Name | camel}}, str)
				} else {
					return nil, fmt.Errorf("field {{.Name}}[%d]: expected string, got %T", i, item)
				}
			}
		} else if arr, ok := v.([]string); ok {
			s.{{.Name | camel}} = arr
		} else {
			return nil, fmt.Errorf("field {{.Name}}: expected []string, got %T", v)
		}
{{- else if eq .GoType "[]int"}}
		if arr, ok := v.([]interface{}); ok {
			s.{{.Name | camel}} = make([]int, 0, len(arr))
			for i, item := range arr {
				switch val := item.(type) {
				case int:
					s.{{.Name | camel}} = append(s.{{.Name | camel}}, val)
				case int64:
					s.{{.Name | camel}} = append(s.{{.Name | camel}}, int(val))
				case float64:
					s.{{.Name | camel}} = append(s.{{.Name | camel}}, int(val))
				default:
					return nil, fmt.Errorf("field {{.Name}}[%d]: expected int, got %T", i, item)
				}
			}
		} else {
			return nil, fmt.Errorf("field {{.Name}}: expected []int, got %T", v)
		}
{{- else if eq .GoType "map[string]string"}}
		if mapVal, ok := v.(map[string]interface{}); ok {
			s.{{.Name | camel}} = make(map[string]string, len(mapVal))
			for key, val := range mapVal {
				if str, ok := val.(string); ok {
					s.{{.Name | camel}}[key] = str
				} else {
					return nil, fmt.Errorf("field {{.Name}}[%s]: expected string, got %T", key, val)
				}
			}
		} else if mapVal, ok := v.(map[string]string); ok {
			s.{{.Name | camel}} = mapVal
		} else {
			return nil, fmt.Errorf("field {{.Name}}: expected map[string]string, got %T", v)
		}
{{- else}}
		// Unsupported type {{.GoType}} - store as-is
		_ = v
{{- end}}
	}
{{end}}
	return s, nil
}

// ToMap converts a Spec to a map[string]interface{}.
// This is used for serialization and testing.
func (s *Spec) ToMap() map[string]interface{} {
	if s == nil {
		return nil
	}

	m := make(map[string]interface{})
{{range .Properties}}
{{- if eq .GoType "string"}}
	if s.{{.Name | camel}} != "" {
		m["{{.Name}}"] = s.{{.Name | camel}}
	}
{{- else if eq .GoType "bool"}}
	if s.{{.Name | camel}} {
		m["{{.Name}}"] = s.{{.Name | camel}}
	}
{{- else if eq .GoType "int"}}
	if s.{{.Name | camel}} != 0 {
		m["{{.Name}}"] = s.{{.Name | camel}}
	}
{{- else if eq .GoType "float64"}}
	if s.{{.Name | camel}} != 0 {
		m["{{.Name}}"] = s.{{.Name | camel}}
	}
{{- else if or (eq .GoType "[]string") (eq .GoType "[]int")}}
	if len(s.{{.Name | camel}}) > 0 {
		m["{{.Name}}"] = s.{{.Name | camel}}
	}
{{- else if eq .GoType "map[string]string"}}
	if len(s.{{.Name | camel}}) > 0 {
		m["{{.Name}}"] = s.{{.Name | camel}}
	}
{{- else}}
	// Unsupported type {{.GoType}}
{{- end}}
{{end}}
	return m
}
