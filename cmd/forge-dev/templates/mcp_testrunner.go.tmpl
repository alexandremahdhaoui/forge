// Code generated by forge-dev. DO NOT EDIT.
// Source: spec.openapi.yaml
{{.ChecksumHeader}}

package {{.PackageName}}

import (
	"context"
	"fmt"

	"github.com/alexandremahdhaoui/forge/pkg/mcpserver"
	"github.com/alexandremahdhaoui/forge/pkg/engineframework"
	"github.com/alexandremahdhaoui/forge/pkg/forge"
	"github.com/alexandremahdhaoui/forge/pkg/mcptypes"
	"github.com/alexandremahdhaoui/forge/pkg/mcputil"
	"github.com/modelcontextprotocol/go-sdk/mcp"
)

// TestRunnerFunc is the signature for the test run operation with typed Spec.
// This is the function that engine authors implement.
type TestRunnerFunc func(ctx context.Context, input mcptypes.RunInput, s *Spec) (*forge.TestReport, error)

// SetupMCPServer creates and configures the MCP server with all required tools.
// It registers run and config-validate tools.
func SetupMCPServer(name string, version string, runFn TestRunnerFunc) (*mcpserver.Server, error) {
	server := mcpserver.New(name, version)

	config := engineframework.TestRunnerConfig{
		Name:        name,
		Version:     version,
		RunTestFunc: wrapTestRunnerFunc(runFn),
	}

	if err := engineframework.RegisterTestRunnerTools(server, config); err != nil {
		return nil, fmt.Errorf("failed to register test runner tools: %w", err)
	}

	// Register config-validate tool
	mcpserver.RegisterTool(server, &mcp.Tool{
		Name:        "config-validate",
		Description: fmt.Sprintf("Validate %s configuration", name),
	}, handleConfigValidate)

	return server, nil
}

// wrapTestRunnerFunc wraps a typed TestRunnerFunc into an engineframework.TestRunnerFunc.
// It handles parsing and validation of the Spec from the input.
func wrapTestRunnerFunc(fn TestRunnerFunc) engineframework.TestRunnerFunc {
	return func(ctx context.Context, input mcptypes.RunInput) (*forge.TestReport, error) {
		// Parse Spec from input
		spec, err := FromMap(input.Spec)
		if err != nil {
			return nil, fmt.Errorf("failed to parse spec: %w", err)
		}

		// Validate Spec
		output := Validate(spec)
		if !output.Valid {
			if len(output.Errors) > 0 {
				return nil, fmt.Errorf("validation failed: %s", output.Errors[0].Message)
			}
			return nil, fmt.Errorf("validation failed")
		}

		// Call the typed test runner function
		return fn(ctx, input, spec)
	}
}

// handleConfigValidate handles the config-validate MCP tool.
func handleConfigValidate(
	_ context.Context,
	_ *mcp.CallToolRequest,
	input mcptypes.ConfigValidateInput,
) (*mcp.CallToolResult, any, error) {
	output := ValidateMap(input.Spec)

	if output.Valid {
		result, artifact := mcputil.SuccessResultWithArtifact(
			"Configuration is valid",
			output,
		)
		return result, artifact, nil
	}

	result, artifact := mcputil.SuccessResultWithArtifact(
		fmt.Sprintf("Configuration validation failed with %d error(s)", len(output.Errors)),
		output,
	)
	return result, artifact, nil
}
