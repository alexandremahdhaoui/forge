# forge-dev

**Generate typed Spec structs and MCP boilerplate from OpenAPI specifications.**

> "I was writing the same validation code and MCP setup for every engine. Now I define my Spec in OpenAPI and forge-dev generates type-safe Go code with validation - consistent across all my engines."

## What problem does forge-dev solve?

Every forge engine needs a typed Spec struct, validation logic, and MCP server boilerplate. forge-dev generates all three from an OpenAPI schema, ensuring consistency and reducing boilerplate.

## How do I use forge-dev?

1. Create `forge-dev.yaml` in your engine directory:

```yaml
name: my-engine
type: builder
version: 0.15.0
description: My custom build engine
openapi:
  specPath: ./spec.openapi.yaml
generate:
  packageName: main
```

2. Create `spec.openapi.yaml` defining your Spec:

```yaml
openapi: 3.0.3
info:
  title: my-engine Spec Schema
  version: 0.15.0
components:
  schemas:
    Spec:
      type: object
      properties:
        outputDir:
          type: string
          description: Output directory
        verbose:
          type: boolean
      required:
        - outputDir
```

3. Add to `forge.yaml`:

```yaml
build:
  - name: generate-my-engine
    src: ./cmd/my-engine
    engine: go://forge-dev

  - name: my-engine
    src: ./cmd/my-engine
    dest: ./build/bin
    engine: go://go-build
    depends: [generate-my-engine]
```

4. Run: `forge build generate-my-engine`

## What files are generated?

| File | Contents |
|------|----------|
| `zz_generated.spec.go` | Typed Spec struct with JSON tags |
| `zz_generated.validate.go` | Validation functions |
| `zz_generated.mcp.go` | MCP server setup boilerplate |

## How do I use the generated code?

```go
func runMCPServer() error {
    server, err := SetupMCPServer(Version, myBuildFunc)
    if err != nil {
        return err
    }
    return server.RunDefault()
}

func myBuildFunc(ctx context.Context, input mcptypes.BuildInput, spec *Spec) (*forge.Artifact, error) {
    // spec is already parsed and validated
    return &forge.Artifact{...}, nil
}
```

## What OpenAPI types are supported?

| OpenAPI Type | Go Type |
|--------------|---------|
| `string` | `string` |
| `boolean` | `bool` |
| `integer` | `int` |
| `number` | `float64` |
| `array` of strings | `[]string` |
| `array` of integers | `[]int` |
| `object` with `additionalProperties` | `map[string]T` |
| `string` with `enum` | `string` (with validation) |

**Limitations:** Arrays of objects, `$ref`, `oneOf`, `anyOf`, `allOf` are not supported.

## How does incremental generation work?

forge-dev computes a SHA256 checksum of source files. Generated files include this checksum:

```go
// Code generated by forge-dev. DO NOT EDIT.
// SourceChecksum: sha256:abc123...
```

If sources are unchanged, generation is skipped.

## What's next?

- [schema.md](schema.md) - Configuration reference
- [ARCHITECTURE.md](../../../ARCHITECTURE.md) - System architecture
