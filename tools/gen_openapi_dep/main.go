// Copyright 2024 Alexandre Mahdhaoui
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

//go:build ignore

// This is a helper script to generate code for go-gen-openapi-dep-detector.
// Run from repo root with: go run ./tools/gen_openapi_dep/main.go

package main

import (
	"context"
	"crypto/sha256"
	"encoding/hex"
	"fmt"
	"io"
	"log"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"gopkg.in/yaml.v3"
)

// Config represents the forge-dev.yaml configuration structure.
type Config struct {
	Name        string         `yaml:"name"`
	Type        string         `yaml:"type"`
	Version     string         `yaml:"version"`
	Description string         `yaml:"description"`
	OpenAPI     OpenAPIConfig  `yaml:"openapi"`
	Generate    GenerateConfig `yaml:"generate"`
}

// OpenAPIConfig contains the OpenAPI spec configuration.
type OpenAPIConfig struct {
	SpecPath string `yaml:"specPath"`
}

// GenerateConfig contains code generation configuration.
type GenerateConfig struct {
	PackageName string `yaml:"packageName"`
}

func main() {
	srcDir := "./cmd/go-gen-openapi-dep-detector"

	// Make srcDir absolute
	cwd, err := os.Getwd()
	if err != nil {
		log.Fatalf("getting cwd: %v", err)
	}
	srcDir = filepath.Join(cwd, srcDir)

	log.Printf("Generating code for %s", srcDir)

	// Read config
	configPath := filepath.Join(srcDir, "forge-dev.yaml")
	configData, err := os.ReadFile(configPath)
	if err != nil {
		log.Fatalf("reading forge-dev.yaml: %v", err)
	}

	var config Config
	if err := yaml.Unmarshal(configData, &config); err != nil {
		log.Fatalf("parsing forge-dev.yaml: %v", err)
	}

	// Read spec
	specPath := filepath.Join(srcDir, config.OpenAPI.SpecPath)
	loader := openapi3.NewLoader()
	doc, err := loader.LoadFromFile(specPath)
	if err != nil {
		log.Fatalf("loading OpenAPI spec: %v", err)
	}

	// Compute checksum
	checksum, err := computeChecksum(configPath, specPath)
	if err != nil {
		log.Fatalf("computing checksum: %v", err)
	}

	// Generate spec file
	specContent := generateSpecFile(doc, config, checksum)
	specFilePath := filepath.Join(srcDir, "zz_generated.spec.go")
	if err := os.WriteFile(specFilePath, []byte(specContent), 0o644); err != nil {
		log.Fatalf("writing spec file: %v", err)
	}
	log.Printf("Generated %s", specFilePath)

	// Generate validate file
	validateContent := generateValidateFile(doc, config, checksum)
	validateFilePath := filepath.Join(srcDir, "zz_generated.validate.go")
	if err := os.WriteFile(validateFilePath, []byte(validateContent), 0o644); err != nil {
		log.Fatalf("writing validate file: %v", err)
	}
	log.Printf("Generated %s", validateFilePath)

	// Generate mcp file
	mcpContent := generateMCPFile(config, checksum)
	mcpFilePath := filepath.Join(srcDir, "zz_generated.mcp.go")
	if err := os.WriteFile(mcpFilePath, []byte(mcpContent), 0o644); err != nil {
		log.Fatalf("writing mcp file: %v", err)
	}
	log.Printf("Generated %s", mcpFilePath)

	log.Printf("Successfully generated 3 files for %s", config.Name)
}

func computeChecksum(paths ...string) (string, error) {
	h := sha256.New()
	for _, p := range paths {
		data, err := os.ReadFile(p)
		if err != nil {
			return "", err
		}
		h.Write(data)
	}
	return "sha256:" + hex.EncodeToString(h.Sum(nil)), nil
}

func generateSpecFile(doc *openapi3.T, config Config, checksum string) string {
	var sb strings.Builder

	sb.WriteString("// Code generated by forge-dev. DO NOT EDIT.\n")
	sb.WriteString("// Source: spec.openapi.yaml\n")
	sb.WriteString(fmt.Sprintf("// Checksum: %s\n", checksum))
	sb.WriteString(fmt.Sprintf("// Generated: %s\n\n", time.Now().UTC().Format(time.RFC3339)))
	sb.WriteString(fmt.Sprintf("package %s\n\n", config.Generate.PackageName))

	// Get Spec schema
	specSchema := doc.Components.Schemas["Spec"]
	if specSchema == nil {
		log.Printf("Warning: No Spec schema found in OpenAPI spec")
		sb.WriteString("// Spec represents the engine configuration.\n")
		sb.WriteString("type Spec struct {}\n")
		return sb.String()
	}

	sb.WriteString("// Spec represents the engine configuration.\n")
	sb.WriteString("type Spec struct {\n")

	// Sort properties for deterministic output
	props := make([]string, 0, len(specSchema.Value.Properties))
	for name := range specSchema.Value.Properties {
		props = append(props, name)
	}
	sort.Strings(props)

	for _, name := range props {
		prop := specSchema.Value.Properties[name]
		goType := openAPITypeToGo(prop.Value)
		fieldName := strings.Title(name)
		jsonTag := fmt.Sprintf("`json:\"%s,omitempty\"`", name)

		if prop.Value.Description != "" {
			sb.WriteString(fmt.Sprintf("\t// %s\n", prop.Value.Description))
		}
		sb.WriteString(fmt.Sprintf("\t%s %s %s\n", fieldName, goType, jsonTag))
	}

	sb.WriteString("}\n")

	return sb.String()
}

func generateValidateFile(doc *openapi3.T, config Config, checksum string) string {
	var sb strings.Builder

	sb.WriteString("// Code generated by forge-dev. DO NOT EDIT.\n")
	sb.WriteString("// Source: spec.openapi.yaml\n")
	sb.WriteString(fmt.Sprintf("// Checksum: %s\n", checksum))
	sb.WriteString(fmt.Sprintf("// Generated: %s\n\n", time.Now().UTC().Format(time.RFC3339)))
	sb.WriteString(fmt.Sprintf("package %s\n\n", config.Generate.PackageName))

	sb.WriteString(`import (
	"encoding/json"

	"github.com/alexandremahdhaoui/forge/pkg/mcptypes"
)

// FromMap creates a Spec from a map.
func FromMap(m map[string]interface{}) (*Spec, error) {
	data, err := json.Marshal(m)
	if err != nil {
		return nil, err
	}
	var s Spec
	if err := json.Unmarshal(data, &s); err != nil {
		return nil, err
	}
	return &s, nil
}

// ValidateMap validates a spec map and returns validation output.
func ValidateMap(m map[string]interface{}) *mcptypes.ConfigValidateOutput {
	output := &mcptypes.ConfigValidateOutput{
		Valid:  true,
		Errors: []mcptypes.ValidationError{},
	}

	if m == nil {
		return output
	}

`)

	// Get Spec schema
	specSchema := doc.Components.Schemas["Spec"]
	if specSchema != nil {
		// Sort properties for deterministic output
		props := make([]string, 0, len(specSchema.Value.Properties))
		for name := range specSchema.Value.Properties {
			props = append(props, name)
		}
		sort.Strings(props)

		for _, name := range props {
			prop := specSchema.Value.Properties[name]
			validatorFunc := getValidatorFunc(prop.Value)
			if validatorFunc != "" {
				sb.WriteString(fmt.Sprintf("\t// Validate %s\n", name))
				sb.WriteString(fmt.Sprintf("\tif _, err := %s(m, \"%s\"); err != nil {\n", validatorFunc, name))
				sb.WriteString("\t\toutput.Valid = false\n")
				sb.WriteString("\t\toutput.Errors = append(output.Errors, *err)\n")
				sb.WriteString("\t}\n\n")
			}
		}
	}

	sb.WriteString("\treturn output\n")
	sb.WriteString("}\n")

	return sb.String()
}

func generateMCPFile(config Config, checksum string) string {
	var sb strings.Builder

	sb.WriteString("// Code generated by forge-dev. DO NOT EDIT.\n")
	sb.WriteString("// Source: spec.openapi.yaml\n")
	sb.WriteString(fmt.Sprintf("// Checksum: %s\n", checksum))
	sb.WriteString(fmt.Sprintf("// Generated: %s\n\n", time.Now().UTC().Format(time.RFC3339)))
	sb.WriteString(fmt.Sprintf("package %s\n\n", config.Generate.PackageName))

	sb.WriteString(`import (
	"context"
	"fmt"

	"github.com/alexandremahdhaoui/forge/internal/mcpserver"
	"github.com/alexandremahdhaoui/forge/pkg/mcptypes"
	"github.com/alexandremahdhaoui/forge/pkg/mcputil"
	"github.com/modelcontextprotocol/go-sdk/mcp"
)

// SetupMCPServerBase creates and configures the base MCP server.
// It registers only the config-validate tool. The detectDependencies tool
// must be registered manually since each detector has different input types.
func SetupMCPServerBase(name string, version string) (*mcpserver.Server, error) {
	server := mcpserver.New(name, version)

	// Register config-validate tool
	mcpserver.RegisterTool(server, &mcp.Tool{
		Name:        "config-validate",
		Description: fmt.Sprintf("Validate %s configuration", name),
	}, handleConfigValidate)

	return server, nil
}

// handleConfigValidate handles the config-validate MCP tool.
func handleConfigValidate(
	_ context.Context,
	_ *mcp.CallToolRequest,
	input mcptypes.ConfigValidateInput,
) (*mcp.CallToolResult, any, error) {
	output := ValidateMap(input.Spec)

	if output.Valid {
		result, artifact := mcputil.SuccessResultWithArtifact(
			"Configuration is valid",
			output,
		)
		return result, artifact, nil
	}

	result, artifact := mcputil.SuccessResultWithArtifact(
		fmt.Sprintf("Configuration validation failed with %d error(s)", len(output.Errors)),
		output,
	)
	return result, artifact, nil
}
`)

	return sb.String()
}

func openAPITypeToGo(schema *openapi3.Schema) string {
	switch schema.Type.Slice()[0] {
	case "string":
		return "*string"
	case "integer":
		return "*int"
	case "number":
		return "*float64"
	case "boolean":
		return "*bool"
	case "array":
		if schema.Items != nil {
			itemType := openAPITypeToGo(schema.Items.Value)
			// Remove pointer for slice items
			itemType = strings.TrimPrefix(itemType, "*")
			return "[]" + itemType
		}
		return "[]interface{}"
	case "object":
		if schema.AdditionalProperties.Has != nil && *schema.AdditionalProperties.Has {
			return "map[string]interface{}"
		}
		return "map[string]interface{}"
	default:
		return "interface{}"
	}
}

func getValidatorFunc(schema *openapi3.Schema) string {
	switch schema.Type.Slice()[0] {
	case "string":
		return "mcptypes.ValidateString"
	case "integer":
		return "mcptypes.ValidateInt"
	case "number":
		return "mcptypes.ValidateFloat64"
	case "boolean":
		return "mcptypes.ValidateBool"
	case "array":
		if schema.Items != nil && len(schema.Items.Value.Type.Slice()) > 0 && schema.Items.Value.Type.Slice()[0] == "string" {
			return "mcptypes.ValidateStringSlice"
		}
		return ""
	default:
		return ""
	}
}
